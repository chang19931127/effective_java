/**
 * 对象序列化API，他提供了一个框架，用来将对象编码成字节流。
 * 并从字节流编码中重构对象。“讲一个对象编码成一个字节流”，称为将该对象序列化
 * 相反的处理过程被称为反序列化。一旦对象被序列化后，他的编码就可以从一台正在运行
 * 的虚拟机被传递到另一台虚拟机上，或者被存储到磁盘上，供以后反序列化时用。
 * 序列化技术为远程通信提供了标准的线路级对象表示法，也为JavaBeans组件结构提供了
 * 标准的持久化数据格式。因此序列化有很多种格式，只要转化成字节流！都可以被称作序列化
 * 
 * 请看Serializable接口中的注释文档，有很多内容，会让你收获
 * 接口实现！
 * writeObject() 自定义序列化
 * writeReplace() 替代了writeObject，重新创建对象并转化成流，序列化出去
 * readResolve 针对writeReplace 反序列化
 * readObject() 自定义反序列化！
 * 一定要了解这些方法！
 * 
 * 
 * 明白什么是序列化，针对计算机的实质操作，就好！！！！！！多思考，多去了解本质，二进制！二进制！二进制！机器懂二进制，我们懂什么？
 * 其实这个序列化仅限于java，性能也不好，不如使用其他开源的操作，google开源的Protobuffer，可以跨语言 Hessions，
 * Kryo 仅用于java，但是性能比原生高很多，明白序列化原理，你也可以造个轮子出来，第一步，造一个仅java使用的，第二部，就是跨语言
 * 如何跨语言，就需要开发每一个语言的序列化形式
 * @author Administrator
 *
 */
package me.czd.effective.java.serializable;